#!/bin/bash
#
# ssh to hosts via certificates using hashicorp vault as the Certificate Authority (CA)
#
# Public URL: http://bit.ly/2neL2vI
# Usage: bash <(curl -sSL http://bit.ly/2neL2vI)

# Troubleshooting: Check your current login token
# curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request GET $VAULT_ADDR/v1/auth/token/lookup

# Handle command line arguments / options / positional parameters
set_env() {
  VAULT_HOSTNAME=${VAULT_HOSTNAME:-vault}
  VAULT_PORT=${VAULT_PORT:-8200}
  MAC_GNU_GETOPT_PATH=${MAC_GNU_GETOPT_PATH:-/usr/local/opt/gnu-getopt/bin/getopt}
  URI_SCHEME=${URI_SCHEME:-http} # http for development. https for production.
  VAULT_ADDR=${VAULT_ADDR:-${URI_SCHEME}://${VAULT_HOSTNAME}:${VAULT_PORT}}
  is_authenticated="false"
}

# Install the sshv alias if not installed
install_alias() {
  comment="# Added by configuration-manager@foo.com"
  command="alias sshv='bash <(curl -sSL http://bit.ly/2neL2vI)'"
  path=~/.bashrc

  if ! grep -q -F "${command}" "${path}"; then
    printf "\n%s\n%s" "${comment}" "${command}" >>"${path}"
    printf "sshv was successfully installed (for details, vi ~/.bashrc). To use it, open a new bash login shell or, to use it immediately, enter this:\n  source ~/.bashrc\n\n"
  fi
}

# display help text
display_help() {
cat <<EOF

Welcome to sshv

  Purpose: A vault-aware ssh client

    Usage: sshv [OPTIONS] destination [COMMAND]

  Example: sshv user1@sshserver
  Example: sshv user1@sshserver echo "hello world"

Options:
  -h, --help   Display help

EOF
exit
}

# get options: https://gist.github.com/cosimo/3760587
get_options() {
  if ! OPTS=$(getopt -o h --long help -n 'parse-options' -- "$@"); then display_help; exit; fi
  eval set -- "$OPTS"

  while true; do
    case "$1" in
             -h|--help)  display_help ; shift ;;
             --)  shift ; args=(); until [[ -z ${1+x} ]]; do args+=("$1"); shift; done; break ;;
                     *)  echo "Internal error!" ; display_help; exit 1 ;;
    esac
  done
}

# Which OS are you running?
get_os() {
  unameOut="$(uname -s)"
  case "${unameOut}" in
      Linux*)     os="Linux";;
      Darwin*)    os="Mac";;
      CYGWIN*)    os="Cygwin";;
      MINGW*)     os="MinGw";;
      *)          os="UNKNOWN:${unameOut}"
    esac
}

# Require this
req_jq() {
  if ! type jq &>/dev/null; then
    printf "Please install jq first\n"
    exit 1
  fi
}

# Require this
req_ssh() {
  if ! type ssh &>/dev/null; then
    printf "Please install ssh first\n"
    exit 1
  fi
}

# If running MacOS, require coreutils is installed (use greadlink as a proxy)
req_coreutils() {
  if ! type greadlink &>/dev/null; then
    printf "Please install coreutils first: brew install coreutils\n"
    exit 1
  fi
}

# Linux usually has getopt (which allows long options) but MacOS, which is
# based on FreeBSD, needs the gnu version: brew install gnu-getopt
# https://stackoverflow.com/a/402410/1231693
req_getopt() {
  # if getopt not already installed
  if [[ ! -f "${MAC_GNU_GETOPT_PATH}" ]]; then
    printf "Please install getopt first: brew install gnu-getopt\n"
    exit 1
  fi

  # override getopt shell built-in with gnu version but only for this script:
  # https://stackoverflow.com/a/47542834/1231693
  export PATH="/usr/local/opt/gnu-getopt/bin:$PATH"
  export FLAGS_GETOPT_CMD="${MAC_GNU_GETOPT_PATH}"
}

# Check prereqs
check_prereqs() {
  # all OS's require these
  req_ssh
  req_jq

  # sanity checks
  [[ "${VAULT_HOSTNAME}" == "vault" ]] { printf "Error: VAULT_HOSTNAME is not set. Try something like this:\n  \
    export VAULT_HOSTNAME=vault.foo.com"; exit 1; }

  case "${os}" in
      Mac*)     req_coreutils; req_getopt;;
    Linux*)                              ;;
         *)                              ;;
  esac
}

# Check network connectivity
check_network() {
  # On Mac, timeout is part of coreutils (then gtimeout and timeout have same sha1sum)
  if ! timeout 3 bash -c "cat < /dev/null > /dev/tcp/${VAULT_HOSTNAME}/${VAULT_PORT}"; then
      printf "\nError: I couldn't contact the hostname %s on port %s. Check your networking, host name, and port.\n" "${VAULT_HOSTNAME}" "${VAULT_PORT}"
  exit 1
  fi
}

# Create sshv_config_dir
create_sshv_config_dir() {
  mkdir -p ~/.sshv
}

# Validate an existing token, if it exists
check_token() {
  resfile="checktoken.txt"           # file to hold curl results temporarily
  userfile="$HOME/.sshv/ad_username" # path of persisted username

  # if the token exists, check if token is valid
  if [[ -f ~/.sshv/token ]]; then
    # if the token exists, the persisted username should exist too
    [[ -f "${userfile}" ]] && ad_username=$(cat "${userfile}") # load username from disk if persisted

    VAULT_TOKEN="$(cat ~/.sshv/token)"
    curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request GET "$VAULT_ADDR/v1/auth/token/lookup" -o "${resfile}"

    # check for curl / vault failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
    if grep -q "error" "${resfile}"; then
      printf "Error from vault while checking current token: %s. Possible reasons:\n" "$(cat ${resfile})"
      printf "  1. Your vault policy does not have read access to auth/token/lookup.\n"
      printf "  2. Your vault token expired, so you must re-authenticate.\n\n"
      delete_file "${resfile}"
    else # if you get here, your token is presumably still valid
      is_authenticated="true"
    fi
  fi
}

# Get AD username
get_ad_username() {
  read -er -p "Enter your Active Directory (AD) username: " -i "${ad_username}" ad_username
  [[ -z ${ad_username:+x} ]] && { printf "\nError: no username\n"; exit 1; }

  # persist username
  tee "${userfile}" 1>/dev/null <<< "${ad_username}"
}

# Get AD password
get_ad_password() {
  read -er -s -p "Enter your Active Directory (AD) password: " ad_password
  [[ -z ${ad_password:+x} ]] && { printf "\nError: no password\n"; exit 1; }
  printf "\n\n" # breathing room
}

# For (curl) security, persist the AD password to disk temporarily
# For secure curl login (i.e., don't show passwords in bash history or ps listing). Details: https://unix.stackexchange.com/a/385349/171736
persist_ad_password() {
  secret="${1}"
  creds_filepath="$(mktemp)"
  chmod 0700 "${creds_filepath}" # only allow the owner to see this for the split second it exists
  tee "${creds_filepath}" 1>/dev/null <<< "{\"password\": \"${ad_password}\"}"
}

# Get login credentials
get_creds() {
  get_ad_username
  get_ad_password
  persist_ad_password
}

# Send credentials to vault
send_creds() {
  resfile="curl_sig_req_results.txt" # file to hold curl results temporarily

  # try to log in
  curl -sS --request POST --data @"${creds_filepath}" "$VAULT_ADDR/v1/auth/ldap/login/$ad_username" -o "${resfile}"

  # check for curl / vault failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
  if grep -q "error" "${resfile}"; then
    printf "Error from vault while logging into LDAP: %s. Possible reasons:\n" "$(cat ${resfile})"
    printf "  1. $ad_username does not exist in Active Directory.\n" "${ad_username}"
    printf "  2. Your username or password are incorrect.\n"
    delete_file "${resfile}"
    exit 1
   fi

  # get or persist the vault token. tokens are temporary, so attack vector is presumably small
  token="$(jq -r '.auth.client_token' < $resfile)"

  # handle any empty token error
  if [[ -z ${token+x} ]]; then { echo "Error obtaining a vault token. Curl returned: $(cat $resfile)"; delete_file "${resfile}"; exit 1; }; fi

  # persist, secure, and check it
  tee ~/.sshv/token 1>/dev/null <<< "${token}"
  chmod 0700 ~/.sshv/token
  [[ ! -f ~/.sshv/token ]] && echo "WARN: could not persist token to ~/.sshv/token"

  # set the vault token for future API / curl commands
  VAULT_TOKEN="${token}"
}

# Delete the stored credentials
delete_creds() {
  if ! shred -u "${creds_filepath}"; then
    rm -f "${creds_filepath}"
  fi

  # if not deleted, warn
  [[ -f "${creds_filepath}" ]] && "Warning: could not delete password from disk at $creds_filepath."

  unset creds_filepath
  unset ad_password
}

# Log into vault using Active Directory
authenticate_to_vault() {
  check_token

  if [[ $is_authenticated == "false" ]]; then
    get_creds
    send_creds
    delete_creds
  fi
}

# Create a temporary, i.e., worthless after its certificate expires, ssh keypair for this user
# Currently, this creates an rsa keypair. ed25519 not supported yet in vault
# Warning: the ssh-keygen -N '' means that the keypair will NOT have a password (but ttl's are short)
# This approach simplifies things because you don't need ssh-agent or to enter a password in it.
# See https://github.com/ssh-vault/ssh-vault/issues/37
create_keypair() {
  # Note that "echo yes | ... " overwrites any existing output file
  echo printf | ssh-keygen -N '' -t rsa -b 4096 -a 100 -f ~/.ssh/id_rsa_vault >/dev/null
}

# Set parameters
set_csr_parms() {
tee csr.json >/dev/null <<-EOF
	{
	"public_key"       :  "$(tr '\n' '*' <~/.ssh/id_rsa_vault.pub | sed 's/\*/\\n/g')",
	"ttl"              :  "15s",
	"valid_principals" :  "user1",
	"cert_type"        :  "user",
	"key_id"           :  "user1@client1 created by sshv",
	"critical_options" :  {},
	"extension"        :  { "permit-pty":"", "permit-port-forwarding": "" },
	"cert_type"        :  "user"
	}
EOF
}


# delete file
delete_file() {
  [[ -z ${1+x} ]] && { echo "no parameter passed to delete_file"; exit 1; }
  rm -f "${1}"
  [[ -f "${1}" ]] && { echo "error: couldn't delete ${1}"; exit 1; }
}

# Get certificate from Vault (CA)
get_cert() {
  resfile="curl_sig_req_results.txt" # file to hold curl results temporarily

  curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request POST \
  --data @csr.json "${VAULT_ADDR}/v1/users-ca/sign/role1" -o "${resfile}"

  # Check for failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
  if grep -q "error" "${resfile}"; then
    printf "\nError from while getting certificate from vault: %s. Possible reasons:\n" "$(cat ${resfile})"
    printf "  1. In vault, auth/ldap/users/%s does not have a vault policy. \n" "${ad_username}"
    printf "  2. In vault, auth/ldap/users/%s can not read users-ca/sign/role1.\n" "${ad_username}"
    printf "  3. Your vault token's 'token_num_uses' decreased below 0--i.e., you've used this token too many times. Run sshv again.\n"
    delete_file "${resfile}"
    exit 1
   fi

  jq -r ".data.signed_key" < "${resfile}" >~/.ssh/id_rsa_vault-cert.pub
  delete_file "${resfile}"
  delete_file "csr.json"
}

# Run ssh command or give instructions to do that
run_ssh() {
  if [[ -z "${args[*]+x}" ]]; then
    printf "Success. Try something like: sshv user1@sshserver OR sshv user1@sshserver echo hello-world\n"
    display_help
  else
    ssh -o identitiesonly=yes \
        -o certificatefile=~/.ssh/id_rsa_vault-cert.pub \
        -i ~/.ssh/id_rsa_vault \
         "${args[@]}"
  fi
}

# run
main() {
  get_os
  set_env
  check_prereqs
  get_options "$@"
  install_alias
  check_network
  create_sshv_config_dir
  authenticate_to_vault
  create_keypair
  set_csr_parms
  get_cert
  run_ssh
}

# Start here and pass any parameters
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
