#!/bin/bash
#
# ssh to hosts via certificates using hashicorp vault as the Certificate Authority (CA)
#
# Public URL: http://bit.ly/2neL2vI
# Usage: bash <(curl -sL http://bit.ly/2neL2vI)

# Troubleshooting: Check your current login token
# curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request GET $VAULT_ADDR/v1/auth/token/lookup

# Handle command line arguments / options / positional parameters
set_env() {
  VAULT_SSH_HOSTNAME=${VAULT_SSH_HOSTNAME:-} # ssh tunnel here
  VAULT_HOSTNAME=${VAULT_HOSTNAME:-localhost}
  VAULT_PORT=${VAULT_PORT:-8200}
  MAC_GNU_GETOPT_PATH=${MAC_GNU_GETOPT_PATH:-/usr/local/opt/gnu-getopt/bin/getopt}
  URI_SCHEME=${URI_SCHEME:-http} # http for development or ssh tunnel. https for production.
  VAULT_ADDR=${VAULT_ADDR:-${URI_SCHEME}://localhost:${VAULT_PORT}}
  RED='\033[0;31m'
  NC='\033[0m'
  is_authenticated="false"
}

# Handle sigterm
exit_on_signal_SIGINT() {
  delete_tunnel
  echo
  exit 1
}

# Handle sigkill
exit_on_signal_SIGTERM() {
  delete_tunnel
  echo
  exit 1
}

# Set traps to cleanup before ending.
set_traps() {
  # in case the user Ctrl+C'd the last run before deleting the tunnel
  trap exit_on_signal_SIGINT SIGINT
  trap exit_on_signal_SIGTERM SIGTERM
}

# Install the sshv alias if not installed
install_alias() {
  comment="# Added by sshv"
  command1="alias sshv='bash <(curl -sSL http://bit.ly/2neL2vI)'"
  command2="export VAULT_HOSTNAME=${VAULT_HOSTNAME}"
  command3="# End of sshv changes"
  path=~/.bashrc

  if ! grep -q -F "${command1}" "${path}"; then
    printf "\n%s\n%s\n%s\n%s" "${comment}" "${command1}" "${command2}" "${command3}" >> "${path}"
    printf "sshv was successfully installed (i.e., I created an alias called sshv in your ~/.bashrc), but to start it next time (i.e., to execute sshv), you'll first need to open a new terminal window.\n\n"
    display_help
  elif [[ ${#args[@]} -eq 0 ]]; then # if no options and not installing, show help
    display_help
  fi
}

# if running as a container, the (current) assumption is that ~/.sshv/ad_password exists
check_containerized() {
  if [[ -f "$HOME/.sshv/ad_password" ]]; then
    is_container="true"
  else
    is_container="false"
    install_alias
  fi
}

# Create a secure ssh tunnel by adding an ssh_config entry
install_vault_ssh_config() {
  # ensure ~/.ssh exists
  mkdir -p ~/.ssh
  chmod 700 ~/.ssh

  comment="# Added by sshv"
  path="$HOME/.ssh/config"
  [[ -f "$HOME/.ssh/config" ]] || touch "$HOME/.ssh/config" # create if nonexistant

  # if not already there, add this entry
  if ! grep -q -F "${comment}" "${path}"; then
    tee -a "${path}" >/dev/null <<EOF

# Added by sshv
Host vault
   HostName ${VAULT_SSH_HOSTNAME}
   ServerAliveInterval 3
   User fwd
   LocalForward localhost:8200 localhost:8200
   LocalForward localhost:8080 localhost:8080
# End of sshv changes
EOF
  [[ $? -eq 0 ]] || print "Error: could not update your ${path}\n"
fi
}

# create an ssh tunnel to vault. The tunnel authenticates and secures traffic
create_tunnel() {
  if ! ssh -NfT vault &>/dev/null; then
    printf "\nError: could not create ssh tunnel. Tips:\n"
    printf "  1. Add your public key to /home/fwd/.ssh/authorized_keys on the vault server (e.g., via a Jenkins job).\n"
    printf "  2. Set permissions on the vault server with chmod 0600 /home/fwd/.ssh/authorized_keys\n"
    printf "  3. Check your spelling of ${RED}%s${NC}\n" "${VAULT_SSH_HOSTNAME}"
    printf "  4. Check for networking problems reaching ${RED}%s${NC}\n\n" "${VAULT_SSH_HOSTNAME}"
    exit 1
  fi
}

# display help text
display_help() {
cat <<EOF

Welcome to sshv

  Purpose: A vault-aware ssh client

    Usage: sshv [OPTIONS] destination [COMMAND]

  Example: sshv user1@sshserver
  Example: sshv user1@sshserver echo "hello world"
  Example: sshv user1@sshserver -- -p 1022 echo "hello world"

Description
  sshv is a wrapper for ssh. It logs into vault, creates a local ssh keypair, sends
  the resulting public key to vault's CA (ssh secrets engine) for signing, receives
  the resulting certificate, and calls ssh with arguments to use the certificate
  against the user@server you specify.

Options:
  -h, --help          Display help
  -f, --portforward   Enable http://localhost:8080 and :8200. Exit with Ctrl+C
  -u, --uninstall     Uninstall sshv
  --                  Send everything after 2 dashes as arguments to ssh, not sshv

EOF
exit
}

# enable port forwards
port_forward() {
  # see ~/.ssh/config
	printf "\nPort forwarding enabled. Options:\n  1. open vault: http://localhost:8200\n  2. open jenkins: http://localhost:8080\n  3. quit: ctrl+c\n\n"
	ssh -NT vault
}

# uninstall sshv
uninstall_sshv() {
  sed '/# Added by sshv/,/# End of sshv/d' ~/.ssh/config > tmpfile && mv tmpfile  ~/.ssh/config
  sed '/# Added by sshv/,/# End of sshv/d' ~/.bashrc > tmpfile && mv tmpfile ~/.bashrc
  mv ~/.sshv "$(mktemp -d)"  # rather than make a destructive mistake with rm, do a mv to tmp, which will be deleted on reboot
  echo "sshv succesfully uninstalled"
  exit 0
}

# get options: https://gist.github.com/cosimo/3760587
get_options() {
  if ! OPTS=$(getopt -o hfu --long help,portforward,uninstall -n 'parse-options' -- "$@"); then display_help; exit; fi
  eval set -- "$OPTS"

  while true; do
    case "$1" in
             -h|--help)  display_help ; shift ;;
             -f|--portforward)  port_forward ; shift ;;
             -u|--uninstall)  uninstall_sshv ; shift ;;
             --)  shift ; args=(); until [[ -z ${1+x} ]]; do args+=("$1"); shift; done; break ;;
                     *)  echo "Internal error!" ; display_help; exit 1 ;;
    esac
  done
}

# Which OS are you running?
get_os() {
  unameOut="$(uname -s)"
  case "${unameOut}" in
      Linux*)     os="Linux";;
      Darwin*)    os="Mac";;
      CYGWIN*)    os="Cygwin";;
      MINGW*)     os="MinGw";;
      *)          os="UNKNOWN:${unameOut}"
    esac
}

# Require this
req_jq() {
  if ! type jq &>/dev/null; then
    printf "Please install jq first\n"
    exit 1
  fi
}

# Require this
req_ssh() {
  if ! type ssh &>/dev/null; then
    printf "Please install ssh first\n"
    exit 1
  fi
}

# If running MacOS, require coreutils is installed (use greadlink as a proxy)
req_coreutils() {
  if ! type greadlink &>/dev/null; then
    printf "Please install coreutils first: brew install coreutils\n"
    exit 1
  fi
}

# Linux usually has getopt (which allows long options) but MacOS, which is
# based on FreeBSD, needs the gnu version: brew install gnu-getopt
# https://stackoverflow.com/a/402410/1231693
req_getopt() {
  # if getopt not already installed
  if [[ ! -f "${MAC_GNU_GETOPT_PATH}" ]]; then
    printf "Please install getopt first: brew install gnu-getopt\n"
    exit 1
  fi

  # override getopt shell built-in with gnu version but only for this script:
  # https://stackoverflow.com/a/47542834/1231693
  export PATH="/usr/local/opt/gnu-getopt/bin:$PATH"
  export FLAGS_GETOPT_CMD="${MAC_GNU_GETOPT_PATH}"
}

# make sure we have an ssh hostname so we can tunnel traffic to vault
get_ssh_hostname() {
  local path="$HOME/.sshv/vault_ssh_hostname"
  local hostname="vault.foo.com"

  if [[ ! -f "${path}" ]]; then
    read -er -p "Enter the vault ssh server's public hostname or IP: " -i "${hostname}" hostname
    echo "${hostname}" > "${path}"
  fi

  VAULT_SSH_HOSTNAME=$(cat "${path}")
}

# Check prereqs
check_prereqs() {
  # all OS's require these
  req_ssh
  req_jq

  case "${os}" in
      Mac*)     req_coreutils; req_getopt;;
    Linux*)                              ;;
         *)                              ;;
  esac
}

# Check network connectivity
check_network() {
  # Check if curl results are meaningful. Otherwise, ssh may work to the host but vault's container isn't running.
  # On Mac, timeout is part of coreutils (then gtimeout and timeout have same sha1sum)
  result="$(timeout 3 curl -sS --request GET http://localhost:${VAULT_PORT}/v1/auth/token/lookup)"
  if [[ ! $result == *"missing client token"* ]]; then
      printf "\n${RED}Error${NC}: curl -sS --request GET http://localhost:%s/v1/auth/token/lookup did ${RED}NOT${NC} return the expected \"missing client token\". Is vault running?\n\n" "${VAULT_PORT}"
      exit 1
  fi
}

# Create sshv_config_dir
create_sshv_config_dir() {
  mkdir -p ~/.sshv
}

# Validate an existing token, if it exists
check_token() {
  resfile="checktoken.txt"           # file to hold curl results temporarily
  userfile="$HOME/.sshv/ad_username" # path of persisted username

  # if the token exists, check if token is valid
  if [[ -f ~/.sshv/token ]]; then
    # if the token exists, the persisted username should exist too
    [[ -f "${userfile}" ]] && ad_username=$(cat "${userfile}") # load username from disk if persisted

    VAULT_TOKEN="$(cat ~/.sshv/token)"
    curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request GET "$VAULT_ADDR/v1/auth/token/lookup" -o "${resfile}"

    # check for curl / vault failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
    if grep -q "error" "${resfile}"; then
      printf "Error from vault while checking current token: ${RED}%s${NC}. Possible reasons:\n" "$(cat ${resfile})"
      printf "  1. Your vault policy does not have read access to auth/token/lookup.\n"
      printf "  2. Your vault token expired, so you must re-authenticate.\n\n"
      delete_file "${resfile}"
    else # if you get here, your token is presumably still valid
      is_authenticated="true"
    fi
  fi
}

# Get AD username
get_ad_username() {
  # the username may be persisted in ~/.sshv when running sshv as a container
  if [[ "$is_container" == "true" ]]; then
    ad_username=$(base64 --decode -i ~/.sshv/ad_username)
  else
    read -er -p "Enter your Active Directory (AD) username: " -i "${ad_username}" ad_username
  fi

  # ensure that it's not empty
  [[ -z ${ad_username:+x} ]] && { printf "\nError: no username\n"; exit 1; }

  # persist username
  tee "${userfile}" 1>/dev/null <<< "${ad_username}"
}

# Get AD password
get_ad_password() {
  # the password may be persisted in ~/.sshv when running sshv as a container
  if [[ "$is_container" == "true" ]]; then
    ad_password=$(base64 --decode -i ~/.sshv/ad_password)
  else
    read -er -s -p "Enter your Active Directory (AD) password: " ad_password
  fi

  # ensure it's not empty
  [[ -z ${ad_password:+x} ]] && { printf "\nError: no password\n"; exit 1; }

  printf "\n\n" # breathing room
}

# For (curl) security, persist the AD password to disk temporarily
# For secure curl login (i.e., don't show passwords in bash history or ps listing). Details: https://unix.stackexchange.com/a/385349/171736
persist_ad_password() {
  secret="${1}"
  creds_filepath="$(mktemp)"
  chmod 0700 "${creds_filepath}" # only allow the owner to see this for the split second it exists
  tee "${creds_filepath}" 1>/dev/null <<< "{\"password\": \"${ad_password}\"}"
}

# Get login credentials
get_creds() {
  get_ad_username
  get_ad_password
  persist_ad_password
}

# Send credentials to vault
send_creds() {
  resfile="curl_sig_req_results.txt" # file to hold curl results temporarily

  # try to log in
  curl -sS --request POST --data @"${creds_filepath}" "$VAULT_ADDR/v1/auth/ldap/login/$ad_username" -o "${resfile}"

  # check for curl / vault failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
  if grep -q "error" "${resfile}"; then
    printf "Error from vault while logging into LDAP: ${RED}%s${NC}. Possible reasons:\n" "$(cat ${resfile})"
    printf "  1. $ad_username does not exist in Active Directory.\n" "${ad_username}"
    printf "  2. Your username or password are incorrect.\n"
    delete_file "${resfile}"
    exit 1
   fi

  # get or persist the vault token. tokens are temporary, so attack vector is presumably small
  token="$(jq -r '.auth.client_token' < $resfile)"

  # handle any empty token error
  if [[ -z ${token+x} ]]; then { echo "Error obtaining a vault token. Curl returned: $(cat $resfile)"; delete_file "${resfile}"; exit 1; }; fi

  # persist, secure, and check it
  tee ~/.sshv/token 1>/dev/null <<< "${token}"
  chmod 0700 ~/.sshv/token
  [[ ! -f ~/.sshv/token ]] && echo "WARN: could not persist token to ~/.sshv/token"

  # set the vault token for future API / curl commands
  VAULT_TOKEN="${token}"
}

# Delete the stored credentials
delete_creds() {
  if ! shred -u "${creds_filepath}" 2>/dev/null; then
    rm -f "${creds_filepath}" 2>/dev/null
  fi

  # if not deleted, warn
  [[ -f "${creds_filepath}" ]]       && "Warning: could not delete password from disk at $creds_filepath."
  [[ -f "$HOME/.sshv/ad_password" ]] && "Warning: could not delete password from disk at $HOME/.sshv/ad_password."

  unset creds_filepath
  unset ad_password
}

# Log into vault using Active Directory
authenticate_to_vault() {
  check_token

  if [[ $is_authenticated == "false" ]]; then
    get_creds
    send_creds
    delete_creds
  fi
}

# Create a temporary, i.e., worthless after its certificate expires, ssh keypair for this user
# Currently, this creates an rsa keypair. ed25519 not supported yet in vault
# Warning: the ssh-keygen -N '' means that the keypair will NOT have a password (but ttl's are short)
# This approach simplifies things because you don't need ssh-agent or to enter a password in it.
# See https://github.com/ssh-vault/ssh-vault/issues/37
create_keypair() {
  # Note that "echo yes | ... " overwrites any existing output file
  echo printf | ssh-keygen -N '' -t rsa -b 4096 -a 100 -f ~/.ssh/id_rsa_vault >/dev/null
}

# Set parameters
set_csr_parms() {
tee csr.json >/dev/null <<-EOF
	{
	"public_key"       :  "$(tr '\n' '*' <~/.ssh/id_rsa_vault.pub | sed 's/\*/\\n/g')",
	"ttl"              :  "15s",
	"valid_principals" :  "${ad_username}",
	"cert_type"        :  "user",
	"key_id"           :  "${ad_username} from $(hostname -f) $(ifconfig | awk '/inet 9./{print $2}') on $(date). created by vault via sshv",
	"critical_options" :  {},
	"extension"        :  { "permit-pty":"", "permit-port-forwarding": "" },
	"cert_type"        :  "user"
	}
EOF
}


# delete file
delete_file() {
  [[ -z ${1+x} ]] && { echo "no parameter passed to delete_file"; exit 1; }
  rm -f "${1}"
  [[ -f "${1}" ]] && { echo "error: couldn't delete ${1}"; exit 1; }
}

# Get certificate from Vault (CA)
get_cert() {
  resfile="curl_sig_req_results.txt" # file to hold curl results temporarily

  curl -sS --header "X-Vault-Token: $VAULT_TOKEN" --request POST \
  --data @csr.json "${VAULT_ADDR}/v1/users-ca/sign/role1" -o "${resfile}"

  # Check for failure. Example: {"errors":["1 error occurred:\n\t* permission denied\n"]}
  if grep -q "error" "${resfile}"; then
    printf "\nError from vault while getting certificate from vault: ${RED}%s${NC}. Possible reasons:\n" "$(cat ${resfile})"
    printf "  1. In vault, auth/ldap/users/${RED}%s${NC} does not have a vault policy. \n" "${ad_username}"
    printf "  2. In vault, auth/ldap/users/${RED}%s${NC} can not read users-ca/sign/role1.\n" "${ad_username}"
    printf "  3. Your vault token's 'token_num_uses' decreased below 0--i.e., you've used this token too many times. Run sshv again.\n"
    delete_file "${resfile}"
    exit 1
   fi

  jq -r ".data.signed_key" < "${resfile}" >~/.ssh/id_rsa_vault-cert.pub
  delete_file "${resfile}"
  delete_file "csr.json"
}

# Run ssh command or give instructions to do that
run_ssh() {
  if [[ -z "${args[*]+x}" ]]; then
    display_help
  else
    ssh -o identitiesonly=yes \
        -o certificatefile=~/.ssh/id_rsa_vault-cert.pub \
        -i ~/.ssh/id_rsa_vault \
         "${args[@]}"
  fi
}

# delete the ssh tunnel created earlier to avoid port conflicts on 8200
delete_tunnel() {
  # build an array of all PIDs doing ssh to vault. E.g., 123 456 789
  tunnel_pids=("$(ps ax | awk '/[s]sh -NfT vault/{print $1}' | tr '\n' ' ')")

  # kill them all
  if [[ ! "${tunnel_pids[*]}" == "" ]]; then
    kill ${tunnel_pids[@]}
  fi
}

# run
main() {
  set_traps
  get_os
  set_env
  create_sshv_config_dir
  check_prereqs
  get_options "$@"
  check_containerized
  get_ssh_hostname
  install_vault_ssh_config
  create_tunnel
  check_network
  authenticate_to_vault
  create_keypair
  set_csr_parms
  get_cert
  run_ssh
  delete_tunnel
}

# Start here and pass any parameters
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
